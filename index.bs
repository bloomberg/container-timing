<pre class='metadata'>
Title: Container Timing API
Shortname: container-timing
Level: 1
Status: ED
Group: webperf
URL: https://github.com/bloomberg/container-timing
Repository: https://github.com/bloomberg/container-timing
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/container-timing
Editor: Jason Williams, Bloomberg, jasonwilliams4@bloomberg.net
Editor: Jos√© Dapena Paz, Igalia, jdapena@igalia.com
Abstract: This specification defines an API that enables monitoring when annotated sections of the DOM are displayed on screen and have finished their initial paint.
Markup Shorthands: css no, markdown yes
</pre>


Introduction {#intro}
=====================

The Container Timing API enables monitoring when annotated sections of the DOM are displayed on screen and have finished their initial paint. A developer can mark subsections of the DOM with the <{html-global/containertiming}> attribute (similar to <code>elementtiming</code> for the Element Timing API) and receive performance entries when that section has been painted for the first time.

This API allows developers to measure the timing of various components in their pages. As developers increasingly organize their applications into components, there's a growing demand to measure performance on subsections of an application or a web page.

Unlike Element Timing, it is not possible for the renderer to know when a section of the DOM has finished painting (there could be future changes, asynchronous requests for new images, slow loading buttons, etc.), so this API emits candidates in the form of {{PerformanceEntry}} objects when there has been an update.

Motivation {#motivation}
=========================

Developers want to measure when subsections of the DOM have been painted, such as tables, widgets, or other components, so they can track paint times and submit them to analytics. Current Web APIs don't adequately support this:

- **Element Timing** is limited in what it can support and cannot be used for whole sections.
- **Largest Contentful Paint** (LCP) isn't useful enough to time when specific parts of the page have loaded.
- **User-space polyfills** have significant drawbacks, such as:
    - Needing to mark elements before painting (requiring server-side changes or blocking rendering)
    - Requiring a MutationObserver to catch newly injected elements
    - Needing to run in the document head, increasing time to first paint
    - Can be less efficient at rectangle tracking compared to browser built-in 2D engines

Web authors know their domain better than anyone else and want to communicate the performance of their own content blocks in ways their users or organization would understand (e.g., ["time to first tweet"](https://youtu.be/1jGaov-4ZcQ?si=KBBmjPIl6L3-JUSp&t=2904)).

Usage Example {#example-usage}
===============================

The following example demonstrates how to register a container root and observe its paint timings.

<div class="example">
Registration is on a per-element basis using the <{html-global/containertiming}> attribute:

```html
<div containertiming="foobar">
  <main>...</main>
  <aside>...</aside>
</div>

<script>
  const observer = new PerformanceObserver((list) => {
    let perfEntries = list.getEntries();
    for (const entry of perfEntries) {
      console.log('Container painted:', entry.identifier,
                  'at', entry.startTime,
                  'size:', entry.size);
    }
  });
  observer.observe({ entryTypes: ["container"] });
</script>
```

The attribute should be set before the element is added to the document (in HTML, or if set in JavaScript, before adding it to the document). Setting the attribute retroactively will only capture subsequent events and future paints.
</div>

Ignoring Subtrees {#ignoring-subtrees}
---------------------------------------

<div class="example">
Parts of the DOM tree can be ignored using the <{html-global/containertiming-ignore}> attribute:

```html
<div containertiming="foobar">
  <main>...</main>
  <!-- Aside updates won't trigger container timing events -->
  <aside containertiming-ignore>...</aside>
</div>
```
</div>

Terminology {#terminology}
===========================

A <dfn export>container root</dfn> is an {{Element}} that has the <{html-global/containertiming}> attribute.

An <dfn export>ignored subtree</dfn> is a subtree rooted at an {{Element}} with the <{html-global/containertiming-ignore}> attribute.

A <dfn export>painted region</dfn> is a region (collection of rectangles) representing all the painted portions of a [=container root=] accumulated since it was first observed.

The <dfn export>container timing API</dfn> provides timing information about when container roots are painted to the screen.


The {{PerformanceContainerTiming}} Interface {#performance-container-timing}
============================================================================

<pre class="idl">
[Exposed=Window]
interface PerformanceContainerTiming : PerformanceEntry {
    readonly attribute DOMString identifier;
    readonly attribute DOMRectReadOnly intersectionRect;
    readonly attribute unsigned long long size;
    readonly attribute DOMHighResTimeStamp firstRenderTime;
    readonly attribute Element? lastPaintedElement;
};
</pre>

<div dfn-for="PerformanceContainerTiming">
A {{PerformanceContainerTiming}} object reports timing information for a [=container root=].

The <dfn attribute>identifier</dfn> attribute returns the value of the <{html-global/containertiming}> attribute of the [=container root=].

The <dfn attribute>intersectionRect</dfn> attribute returns a {{DOMRectReadOnly}} representing the bounding box of all paints accumulated so far within this [=container root=].

The <dfn attribute>size</dfn> attribute returns the size in pixels of the combined [=painted region=] within this [=container root=].

The <dfn attribute>firstRenderTime</dfn> attribute returns a {{DOMHighResTimeStamp}} indicating when the [=container root=] was first painted.

The <dfn attribute>lastPaintedElement</dfn> attribute returns the {{Element}} that was most recently painted within the [=container root=], or null if no element has been painted yet.

The {{PerformanceEntry/entryType}} attribute must return "<code>container</code>".

The {{PerformanceEntry/name}} attribute must return the empty string.

The {{PerformanceEntry/startTime}} attribute must return the {{DOMHighResTimeStamp}} of the latest paint time for this [=container root=].

The {{PerformanceEntry/duration}} attribute must return 0.
</div>

Processing Model {#processing-model}
=====================================

Note: A user agent implementing the Container Timing API would need to include <code>"container"</code> in {{PerformanceObserver/supportedEntryTypes}} for {{Window}} contexts.
This allows developers to detect support for container timing.


Extensions to the {{Element}} Interface {#extensions-to-element}
----------------------------------------------------------------
<pre class="idl">
partial interface Element {
    [CEReactions] attribute DOMString containertiming;
    [CEReactions] attribute DOMString? containertimingIgnore;
};
</pre>

<div dfn-for="Element">
The <dfn attribute>containertiming</dfn> attribute is a {{DOMString}} that identifies the element as a [=container root=]. The value becomes the {{PerformanceContainerTiming/identifier}} in the corresponding {{PerformanceContainerTiming}} entry.

The <dfn attribute>containertimingIgnore</dfn> attribute, when present, marks the element and its descendants as an [=ignored subtree=] that should not contribute to container timing measurements for ancestor [=container roots=].
</div>

Registering Container Roots {#registering-containers}
------------------------------------------------------

When an {{Element}} with a <{html-global/containertiming}> attribute is connected to the document:

1. The user agent must register the element as a [=container root=].
2. The user agent must initialize an empty [=painted region=] for the [=container root=].
3. The user agent must track all paint operations within the [=container root=]'s subtree, excluding any [=ignored subtrees=].

Reporting Paint Updates {#reporting-paint-updates}
---------------------------------------------------

When the rendering engine paints one or more elements within a [=container root=]:

<div algorithm="report container paint">
To <dfn>report a container paint</dfn> given a [=container root=] |containerRoot| and a list of painted rectangles |rects|:

1. Let |paintedRegionUpdated| be false.
2. Let |renderTime| be the current high resolution time.
3. Let |firstRenderTime| be |containerRoot|'s stored first render time, or |renderTime| if not yet set.
4. If |containerRoot| does not have a stored first render time, set it to |firstRenderTime|.
5. Let |paintedRegion| be the [=painted region=] associated with |containerRoot|.
6. Let |lastPaintedElement| be null.
7. For each rectangle |rect| in |rects|:
    1. If |rect| is within an [=ignored subtree=], continue to the next |rect|.
    2. If |paintedRegion| already fully contains |rect|, continue to the next |rect|.
    3. Set |paintedRegionUpdated| to true.
    4. Set |paintedRegion| to the union of |paintedRegion| and |rect|.
    5. Set |lastPaintedElement| to the {{Element}} associated with |rect|.
8. If |paintedRegionUpdated| is false, return.
9. [=Queue a PerformanceContainerTiming entry=] with:
    * identifier: the value of |containerRoot|'s <{html-global/containertiming}> attribute
    * startTime: |renderTime|
    * firstRenderTime: |firstRenderTime|
    * intersectionRect: the bounding rectangle of |paintedRegion|
    * size: the total area of |paintedRegion|
    * lastPaintedElement: |lastPaintedElement|
            </div>

<div algorithm="queue container timing entry">
To <dfn>queue a PerformanceContainerTiming entry</dfn> given |identifier|, |startTime|, |firstRenderTime|, |intersectionRect|, |size|, and |lastPaintedElement|:

1. Let |entry| be a new {{PerformanceContainerTiming}} object with:
    * {{PerformanceEntry/entryType}}: "<code>container</code>"
    * {{PerformanceEntry/name}}: the empty string
    * {{PerformanceEntry/startTime}}: |startTime|
    * {{PerformanceEntry/duration}}: 0
    * {{PerformanceContainerTiming/identifier}}: |identifier|
    * {{PerformanceContainerTiming/firstRenderTime}}: |firstRenderTime|
    * {{PerformanceContainerTiming/intersectionRect}}: |intersectionRect|
    * {{PerformanceContainerTiming/size}}: |size|
    * {{PerformanceContainerTiming/lastPaintedElement}}: |lastPaintedElement|
2. [=Queue the PerformanceEntry=] |entry|.
3. Do not add |entry| to the performance timeline buffer.

Note: Container timing entries are only delivered to {{PerformanceObserver}}s and are not added to the Performance Timeline buffer to avoid memory overhead from potentially frequent updates.
</div>

Security and Privacy Considerations {#security-privacy}
=======================================================

Cross-Origin Restrictions {#cross-origin}
------------------------------------------

The API respects cross-origin boundaries:

- Elements belonging to cross-origin iframes are not exposed to parent frames.
- No timing information crosses frame boundaries unless explicitly passed by the developer via <code>postMessage</code>.

Information Exposure {#information-exposure}
--------------------------------------------

Most information provided by this API can already be estimated through existing APIs:

- Element Timing returns first rendering time for images and text.
- Paint Timing API provides related timestamps.
- The combination of these APIs could approximate container timing information, though less efficiently.

The API does not expose:

- Internal implementation details of the rendering engine
- Information about elements the developer doesn't already have access to
- Timing information more granular than already available through existing Performance APIs

Timing Attacks {#timing-attacks}
---------------------------------

The API uses {{DOMHighResTimeStamp}} which may be subject to resolution limitations for security purposes, consistent with other Performance APIs.

Privacy Considerations {#privacy}
----------------------------------

The API does not:

- Enable tracking users across sites
- Expose browsing history
- Provide information about user behavior beyond what the site already has access to through script execution

Acknowledgments {#acknowledgments}
===================================

Many thanks for valuable feedback and advice from:

- Barry Pollard
- Michael Mocny
- Scott Haseley
- Sergey Chernyshev

