<pre class='metadata'>
Title: Container Timing API
Shortname: container-timing
Level: none
Status: ED
Group: webperf
URL: https://bloomberg.github.io/container-timing/
Repository: https://github.com/bloomberg/container-timing
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/container-timing
Editor: Jason Williams, Bloomberg
Editor: José Dapena Paz, Igalia, jdapena@igalia.com
Abstract: This specification defines an API that enables monitoring when annotated sections of the DOM are displayed on screen and have finished their initial paint.
Markup Shorthands: css no, markdown yes
</pre>

<pre class=anchors>
urlPrefix: https://w3c.github.io/performance-timeline/; spec: PERFORMANCE-TIMELINE-2;
    type: dfn; url: #dfn-queue-a-performanceentry; text: queue the PerformanceEntry;
urlPrefix: https://w3c.github.io/paint-timing/; spec: PAINT-TIMING;
    type: dfn; url: #paint-timing-info; text: paint timing info;
    type: dfn; for: PaintTimingMixin; url: #painttimingmixin-paint-timing-info; text: paint timing info;
    type: dfn; url: #exposed-for-paint-timing; text: exposed for paint timing;
    type: dfn; url: #pending-image-record; text: pending image record;
    type: dfn; for: pending image record; url: #pending-image-record-element; text: element;
    type: dfn; url: #set-of-owned-text-nodes; text: set of owned text nodes;
urlPrefix: https://w3c.github.io/IntersectionObserver/; spec: INTERSECTION-OBSERVER;
    type: dfn; url: #calculate-intersection-rect-algo; text: intersection rect algorithm;
</pre>

Introduction {#intro}
=====================

The Container Timing API enables monitoring when annotated sections of the DOM are displayed on screen and have finished their initial paint. A developer can mark subsections of the DOM with the {{containertiming}} attribute (similar to <code>elementtiming</code> for the Element Timing API) and receive performance entries when that section has been painted for the first time.

This API allows developers to measure the timing of various components in their pages. As developers increasingly organize their applications into components, there's a growing demand to measure performance on subsections of an application or a web page.

Unlike Element Timing, it is not possible for the renderer to know when a section of the DOM has finished painting (there could be future changes, asynchronous requests for new images, slow loading buttons, etc.), so this API emits candidates in the form of {{PerformanceEntry}} objects when there has been an update.

Motivation {#motivation}
=========================

Developers want to measure when subsections of the DOM have been painted, such as tables, widgets, or other components, so they can track paint times and submit them to analytics. Current Web APIs don't adequately support this:

- **Element Timing** is limited in what it can support and cannot be used for whole sections.
- **Largest Contentful Paint** (LCP) isn't useful enough to time when specific parts of the page have loaded.
- **User-space polyfills** have significant drawbacks, such as:
    - Needing to mark elements before painting (requiring server-side changes or blocking rendering)
    - Requiring a MutationObserver to catch newly injected elements
    - Needing to run in the document head, increasing time to first paint
    - Can be less efficient at rectangle tracking compared to browser built-in 2D engines

Web authors know their domain better than anyone else and want to communicate the performance of their own content blocks in ways their users or organization would understand (e.g., ["time to first tweet"](https://youtu.be/1jGaov-4ZcQ?si=KBBmjPIl6L3-JUSp&t=2904)).

Life Cycle {#life-cycle}
------------------------
In this example life cycle a component will paint multiple pieces of content at different times, each of these times will generate a new {{PerformanceContainerTiming}} entry with updated information.

However, once a region has been painted, subsequent paints of that same region will not generate new entries.
<img src="docs/img/life-cycle-dark.svg" width="679" height="740" style="background: transparent;" alt="Container Timing Life Cycle Diagram">

Usage Example {#example-usage}
===============================

The following example demonstrates how to register a container root and observe its paint timings.

<div class="example">
Registration is on a per-element basis using the {{containertiming}} attribute:

```html
<div containertiming="foobar">
  <main>...</main>
  <aside>...</aside>
</div>

<script>
  const observer = new PerformanceObserver((list) => {
    let perfEntries = list.getEntries();
    for (const entry of perfEntries) {
      console.log('Container painted:', entry.identifier,
                  'at', entry.startTime,
                  'size:', entry.size);
    }
  });
  observer.observe({ entryTypes: ["container"] });
</script>
```

The attribute should be set before the element is added to the document (in HTML, or if set in JavaScript, before adding it to the document). Setting the attribute retroactively will only capture subsequent events and future paints.
</div>

Ignoring Subtrees {#ignoring-subtrees}
---------------------------------------

<div class="example">
Parts of the DOM tree can be ignored using the <{{containertiming-ignore}}> attribute:

```html
<div containertiming="foobar">
  <main>...</main>
  <!-- Aside updates won't trigger container timing events -->
  <aside containertiming-ignore>...</aside>
</div>
```
</div>

Terminology {#terminology}
===========================

A <dfn export>container root</dfn> is an {{Element}} that has the {{containertiming}} attribute.

An <dfn export>ignored subtree</dfn> is a subtree rooted at an {{Element}} with the {{containertiming-ignore}}> attribute.

A <dfn export>painted region</dfn> is a region (collection of rectangles) representing all the painted portions of a [=container root=] accumulated since it was first observed.

The <dfn export>container timing API</dfn> provides timing information about when container roots are painted to the screen.


The {{PerformanceContainerTiming}} Interface {#performance-container-timing}
============================================================================

<pre class="idl">
[Exposed=Window]
interface PerformanceContainerTiming : PerformanceEntry {
    readonly attribute DOMString identifier;
    readonly attribute DOMRectReadOnly intersectionRect;
    readonly attribute unsigned long long size;
    readonly attribute DOMHighResTimeStamp firstRenderTime;
    readonly attribute Element? lastPaintedElement;
    readonly attribute Element? rootElement;
};

PerformanceContainerTiming includes PaintTimingMixin;
</pre>

<div dfn-for="PerformanceContainerTiming">
Each {{PerformanceContainerTiming}} object has these associated concepts:
* An <dfn for="ContainerTiming">identifier</dfn> initially set to an empty string.
* An <dfn for="ContainerTiming">intersectionRect</dfn> initially set to a {{DOMRectReadOnly}} with all values set to 0.
* A <dfn for="ContainerTiming">size</dfn> initially set to 0.
* A <dfn for="ContainerTiming">firstRenderTime</dfn> initially set to 0.
* A <dfn for="ContainerTiming">renderTime</dfn> initially set to 0.
* A <dfn for="ContainerTiming">lastPaintedElement</dfn> containing the associated {{Element}}, initially set to <code>null</code>.
* A <dfn for="ContainerTiming">rootElement</dfn> containing the associated {{Element}} that is the container root, initially set to <code>null</code>.

The {{PerformanceEntry/entryType}} attribute's getter must return the {{DOMString}} <code>"container"</code>.

The {{PerformanceEntry/name}} attribute's getter must return the empty string.

The {{PerformanceEntry/duration}} attribute must return 0.

The {{PerformanceEntry/startTime}} attribute's getter must return the value of [=this=]'s [=ContainerTiming/renderTime=].

The <dfn attribute>identifier</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/identifier=].

The <dfn attribute>intersectionRect</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/intersectionRect=].

The <dfn attribute>size</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/size=].

The <dfn attribute>firstRenderTime</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/firstRenderTime=].

The <dfn attribute>lastPaintedElement</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/lastPaintedElement=].

The <dfn attribute>rootElement</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/rootElement=].

</div>

Note: The user agent needs to maintain the <a>container root records map</a> so that removed content does not introduce memory leaks. In particular, it can tie the lifetime of the entries to weak pointers to the {{Element}}s so that they can be cleaned up sometime after the {{Element}}s are removed. Since the map is not exposed to web developers, this does not expose garbage collection timing.

Processing Model {#processing-model}
=====================================

Note: A user agent implementing the Container Timing API would need to include <code>"container"</code> in {{PerformanceObserver/supportedEntryTypes}} for {{Window}} contexts.
This allows developers to detect support for container timing.


Per-Document State {#per-document-state}
----------------------------------------

For each {{Document}}, the user agent must maintain a <dfn export>container root records map</dfn> that maps [=container root=] {{Element}}s to [=Container Timing Record=] objects.



Extensions to the {{Element}} Interface {#extensions-to-element}
----------------------------------------------------------------

<em>This section will be removed once the [[DOM]] specification had been modified.<em>

We extend the {{Element}} interface as follows:

<pre class="idl">
partial interface Element {
    [CEReactions] attribute DOMString containertiming;
    [CEReactions] attribute DOMString? containertimingIgnore;
};
</pre>

<div dfn-for="Element">
The <dfn attribute>containertiming</dfn> attribute is a {{DOMString}} that identifies the element as a [=container root=]. The value becomes the {{PerformanceContainerTiming/identifier}} in the corresponding {{PerformanceContainerTiming}} entry.

The <dfn attribute>containertiming-ignore</dfn> attribute, when present, marks the element and its descendants as an [=ignored subtree=] that should not contribute to container timing measurements for ancestor [=container roots=].
</div>

Container Timing Record {#container-timing-record}
-----------------------

This specification defines an internal data structure used by the processing model:

<div dfn-for="Container Timing Record">
A <dfn export>Container Timing Record</dfn> has these associated concepts:
* A <dfn>paintTimingInfo</dfn> which is a [=PaintTimingMixin/paint timing info=].
* An <dfn>identifier</dfn> which is a {{DOMString}}.
* A <dfn>paintedRegion</dfn> which is a [=painted region=], initially empty.
* A <dfn>lastNewPaintedAreaPaintTimingInfo</dfn> which is a [=PaintTimingMixin/paint timing info=], initially unset.
* A <dfn>lastNewPaintedAreaElement</dfn> which is an {{Element}} or null, initially null.
* A <dfn>hasPendingChanges</dfn> which is a boolean, initially false.
    </div>

<div algorithm="create a container timing record">
To <dfn>create a Container Timing Record</dfn> given a [=PaintTimingMixin/paint timing info=] |paintTimingInfo| and a {{DOMString}} |identifier|, perform the following steps:

1. Let |record| be a new [=Container Timing Record=].
2. Set |record|'s [=Container Timing Record/paintTimingInfo=] to |paintTimingInfo|.
3. Set |record|'s [=Container Timing Record/identifier=] to |identifier|.
4. Return |record|.
    </div>

Registering Container Roots {#registering-containers}
------------------------------------------------------

When an {{Element}} with a [^containertiming^] content attribute is connected to the document:

1. The user agent must register the element as a [=container root=].
2. The user agent must initialize an empty [=painted region=] for the [=container root=].
3. The user agent must track all paint operations within the [=container root=]'s subtree, excluding any [=ignored subtrees=].

Handle Element Painted for Container Timing {#handle-element-painted}
----------------------------------------------------------------------

<div algorithm="handle element painted for container timing">
When an element is painted and the user agent needs to handle container timing updates, given a {{Document}} |document|, a [=PaintTimingMixin/paint timing info=] |paintTimingInfo|, an {{Element}} |element|, and a {{DOMRectReadOnly}} |intersectionRect|, perform the following steps:

1. If |element| does not [=Contribute to container timing=], return.
2. Let |containerRoot| be the result of <a>get the container root element</a> given |element|.
3. If |containerRoot| is null, return.
4. Let |record| be the entry in |document|'s <a>container root records map</a> for |containerRoot|. If no such entry exists, set |record| to the result of <a>create a Container Timing Record</a> given |paintTimingInfo| and the value of |containerRoot|'s [^containertiming^] content attribute; then add (|containerRoot| → |record|) to |document|'s <a>container root records map</a>.
5. Let |enclosingRect| be the smallest enclosing rectangle of |intersectionRect|.
6. <a>Maybe update the last new painted area</a> for |record| given |document|, |containerRoot|, |element|, |enclosingRect|, and |paintTimingInfo|.
7. Mark the {{Document}} as having pending container timing changes.
        </div>

Note: This algorithm is invoked for each image or text node that paints. The intersection rectangle should be computed using the <a>intersection rect algorithm</a> with the element as target and viewport as root, intersected with the visual viewport. For text nodes, the intersection rectangle is the smallest rectangle containing the border boxes of all text nodes in the <a>set of owned text nodes</a>, intersected with the visual viewport.

Emit Container Timing Entries {#emit-container-timing-entries}
--------------------------------------------------------------

<div algorithm="emit container timing entries">
When asked to emit container timing entries for a {{Document}} |document|, perform the following steps. This should be called once per frame after all paint operations have been processed:

1. If |document| does not have pending container timing changes, return.
2. [=map/For each=] |containerRoot| → |record| of |document|'s <a>container root records map</a>:
    1. If |record|'s [=Container Timing Record/hasPendingChanges=] is false, continue.
    2. <a>Create a Container Timing entry</a> given |record| and |containerRoot|.
    3. Set |record|'s [=Container Timing Record/hasPendingChanges=] to false.
3. Mark the {{Document}} as no longer having pending container timing changes.
        </div>

Note: Unlike some other paint timing APIs that may emit multiple entries per painted element, Container Timing accumulates painted regions for each [=container root=] and emits at most one {{PerformanceContainerTiming}} entry per container root per frame. This batching approach is more efficient and provides a holistic view of the container's paint state.


Getting the parent container root Element {#getting-parent-container-root-element}
--------------------------------------------

<div algorithm="get the parent container root element">
To <dfn>get the parent container root element</dfn> given an {{Element}} |element|, perform the following steps:

1. Let |parent| be |element|'s parentElement.
2. If |parent| is null, return null.
3. Return the result of <a>get the container root element</a> given |parent|.
    </div>

Contributes to Container Timing {#contributes-to-container-timing}
--------------------------------

An {{Element}} <dfn export lt="Contribute to container timing">contributes to the container timing</dfn> of a [=container root=] if all of the following are true:

- It is a descendant of the [=container root=].
- It is not within an [=ignored subtree=].
- It is not in a shadow tree.

<div algorithm="determine contribution to container timing">
To determine whether an {{Element}} |element| contributes to the container timing of a [=container root=] |containerRoot|:

1. If |element| is null, return false.
2. If |element| is in a shadow tree, return false.
3. If |element| is not a descendant of |containerRoot|, return false.
4. If |element| is within an [=ignored subtree=], return false.
5. Return true.
    </div>


Getting the container root Element {#getting-container-root-element}
--------------------------------------

<div algorithm="get the container root element">
To <dfn>get the container root element</dfn> given an {{Element}} |element|, perform the following steps:

1. If |element| is null, return null.
2. If |element|'s [^containertiming^] content attribute is present, return |element|.
3. If |element|'s parentElement is not null, return the result of <a>get the container root element</a> given |element|'s parentElement.
4. Return null.
    </div>

Maybe Update Last New Painted Area {#maybe-update-last-new-painted-area}
-----------------------------------

<div algorithm="maybe update last new painted area">
To <dfn>maybe update the last new painted area</dfn> for a [=Container Timing Record=] |record| given a {{Document}} |document|, a [=container root=] {{Element}} |containerRoot|, an {{Element}} |element|, a {{DOMRectReadOnly}} |enclosingRect|, and a [=PaintTimingMixin/paint timing info=] |paintTimingInfo|, perform the following steps:

1. Let |paintedRegion| be |record|'s [=Container Timing Record/paintedRegion=].
2. If |paintedRegion| fully contains |enclosingRect|, return.
3. Set |record|'s [=Container Timing Record/paintedRegion=] to the union of |paintedRegion| and |enclosingRect|.
4. Set |record|'s [=Container Timing Record/lastNewPaintedAreaPaintTimingInfo=] to |paintTimingInfo|.
5. Set |record|'s [=Container Timing Record/lastNewPaintedAreaElement=] to |element|.
6. Set |record|'s [=Container Timing Record/hasPendingChanges=] to true.
7. If |containerRoot|'s [^containertiming-ignore^] content attribute is present, return.
8. Let |parentContainerRoot| be the result of <a>get the parent container root element</a> given |containerRoot|.
9. If |parentContainerRoot| is null, return.
10. Let |parentRecord| be the entry in |document|'s <a>container root records map</a> for |parentContainerRoot|. If no such entry exists, set |parentRecord| to the result of <a>create a Container Timing Record</a> given |paintTimingInfo| and the value of |parentContainerRoot|'s [^containertiming^] content attribute; then add (|parentContainerRoot| → |parentRecord|) to |document|'s <a>container root records map</a>.
11. <a>Maybe update the last new painted area</a> for |parentRecord| given |document|, |parentContainerRoot|, |element|, |enclosingRect|, and |paintTimingInfo|.
    </div>

Note: This algorithm reports any change to the painted region, regardless of size. Even a 1 pixel change in the painted area will result in a new {{PerformanceContainerTiming}} entry being queued. Developers who wish to filter out small changes may do so by comparing the {{PerformanceContainerTiming/size}} values between entries.

Create a Container Timing Entry {#create-container-timing-entry}
--------------------------------

<div algorithm="create a container timing entry">
In order to <dfn>create a Container Timing entry</dfn> given a [=Container Timing Record=] |record| and a [=container root=] {{Element}} |containerRoot|, the user agent must perform the following steps:

1. Let |entry| be a new {{PerformanceContainerTiming}} entry with its:
    * {{PerformanceEntry/entryType}} set to "<code>container</code>"
    * {{PerformanceEntry/name}} set to the empty string
    * {{PerformanceEntry/startTime}} set to |record|'s [=Container Timing Record/lastNewPaintedAreaPaintTimingInfo=]'s {{PaintTimingMixin/paintTime}}
    * {{PerformanceEntry/duration}} set to 0
    * {{PerformanceContainerTiming/identifier}} set to |record|'s [=Container Timing Record/identifier=]
    * {{PerformanceContainerTiming/firstRenderTime}} set to |record|'s [=Container Timing Record/paintTimingInfo=]'s {{PaintTimingMixin/paintTime}}
    * {{PerformanceContainerTiming/intersectionRect}} set to the bounding rectangle of |record|'s [=Container Timing Record/paintedRegion=]
    * {{PerformanceContainerTiming/size}} set to the total area of |record|'s [=Container Timing Record/paintedRegion=]
    * {{PerformanceContainerTiming/lastPaintedElement}} set to |record|'s [=Container Timing Record/lastNewPaintedAreaElement=]
    * {{PerformanceContainerTiming/rootElement}} set to |containerRoot|
2. <a>Queue the PerformanceEntry</a> |entry|.
    </div>

Security and Privacy Considerations {#security-privacy}
=======================================================

Cross-Origin Restrictions {#cross-origin}
------------------------------------------

The API respects cross-origin boundaries:

- Elements belonging to cross-origin iframes are not exposed to parent frames.
- No timing information crosses frame boundaries unless explicitly passed by the developer via <code>postMessage</code>.

Information Exposure {#information-exposure}
--------------------------------------------

Most information provided by this API can already be estimated through existing APIs:

- Element Timing returns first rendering time for images and text.
- Paint Timing API provides related timestamps.
- The combination of these APIs could approximate container timing information, though less efficiently.

The API does not expose:

- Internal implementation details of the rendering engine
- Information about elements the developer doesn't already have access to
- Timing information more granular than already available through existing Performance APIs

Timing Attacks {#timing-attacks}
---------------------------------

The API uses {{DOMHighResTimeStamp}} which may be subject to resolution limitations for security purposes, consistent with other Performance APIs.

Privacy Considerations {#privacy}
----------------------------------

The API does not:

- Enable tracking users across sites
- Expose browsing history
- Provide information about user behavior beyond what the site already has access to through script execution

Acknowledgments {#acknowledgments}
===================================

Many thanks for valuable feedback and advice from:

- Barry Pollard
- Michael Mocny
- Scott Haseley
- Sergey Chernyshev
