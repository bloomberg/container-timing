<pre class='metadata'>
Title: Container Timing API
Shortname: container-timing
Level: 1
Status: ED
Group: webperf
URL: https://bloomberg.github.io/container-timing/
Repository: https://github.com/bloomberg/container-timing
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/container-timing
Editor: Jason Williams, Bloomberg
Editor: Jos√© Dapena Paz, Igalia, jdapena@igalia.com
Abstract: This specification defines an API that enables monitoring when annotated sections of the DOM are displayed on screen and have finished their initial paint.
Markup Shorthands: css no, markdown yes
</pre>

<pre class=anchors>
urlPrefix: https://w3c.github.io/performance-timeline/; spec: PERFORMANCE-TIMELINE-2;
    type: dfn; url: #dfn-queue-a-performanceentry; text: queue the PerformanceEntry;
</pre>

Introduction {#intro}
=====================

The Container Timing API enables monitoring when annotated sections of the DOM are displayed on screen and have finished their initial paint. A developer can mark subsections of the DOM with the {{containertiming}} attribute (similar to <code>elementtiming</code> for the Element Timing API) and receive performance entries when that section has been painted for the first time.

This API allows developers to measure the timing of various components in their pages. As developers increasingly organize their applications into components, there's a growing demand to measure performance on subsections of an application or a web page.

Unlike Element Timing, it is not possible for the renderer to know when a section of the DOM has finished painting (there could be future changes, asynchronous requests for new images, slow loading buttons, etc.), so this API emits candidates in the form of {{PerformanceEntry}} objects when there has been an update.

Motivation {#motivation}
=========================

Developers want to measure when subsections of the DOM have been painted, such as tables, widgets, or other components, so they can track paint times and submit them to analytics. Current Web APIs don't adequately support this:

- **Element Timing** is limited in what it can support and cannot be used for whole sections.
- **Largest Contentful Paint** (LCP) isn't useful enough to time when specific parts of the page have loaded.
- **User-space polyfills** have significant drawbacks, such as:
    - Needing to mark elements before painting (requiring server-side changes or blocking rendering)
    - Requiring a MutationObserver to catch newly injected elements
    - Needing to run in the document head, increasing time to first paint
    - Can be less efficient at rectangle tracking compared to browser built-in 2D engines

Web authors know their domain better than anyone else and want to communicate the performance of their own content blocks in ways their users or organization would understand (e.g., ["time to first tweet"](https://youtu.be/1jGaov-4ZcQ?si=KBBmjPIl6L3-JUSp&t=2904)).

Life Cycle {#life-cycle}
------------------------
In this example life cycle a component will paint multiple pieces of content at different times, each of these times will generate a new {{PerformanceContainerTiming}} entry with updated information.

However, once a region has been painted, subsequent paints of that same region will not generate new entries.
<img src="docs/img/life-cycle-dark.svg" style="background: transparent;" />

Usage Example {#example-usage}
===============================

The following example demonstrates how to register a container root and observe its paint timings.

<div class="example">
Registration is on a per-element basis using the {{containertiming}} attribute:

```html
<div containertiming="foobar">
  <main>...</main>
  <aside>...</aside>
</div>

<script>
  const observer = new PerformanceObserver((list) => {
    let perfEntries = list.getEntries();
    for (const entry of perfEntries) {
      console.log('Container painted:', entry.identifier,
                  'at', entry.startTime,
                  'size:', entry.size);
    }
  });
  observer.observe({ entryTypes: ["container"] });
</script>
```

The attribute should be set before the element is added to the document (in HTML, or if set in JavaScript, before adding it to the document). Setting the attribute retroactively will only capture subsequent events and future paints.
</div>

Ignoring Subtrees {#ignoring-subtrees}
---------------------------------------

<div class="example">
Parts of the DOM tree can be ignored using the <{{containertiming-ignore}}> attribute:

```html
<div containertiming="foobar">
  <main>...</main>
  <!-- Aside updates won't trigger container timing events -->
  <aside containertiming-ignore>...</aside>
</div>
```
</div>

Terminology {#terminology}
===========================

A <dfn export>container root</dfn> is an {{Element}} that has the {{containertiming}} attribute.

An <dfn export>ignored subtree</dfn> is a subtree rooted at an {{Element}} with the {{containertiming-ignore}}> attribute.

A <dfn export>painted region</dfn> is a region (collection of rectangles) representing all the painted portions of a [=container root=] accumulated since it was first observed.

The <dfn export>container timing API</dfn> provides timing information about when container roots are painted to the screen.


The {{PerformanceContainerTiming}} Interface {#performance-container-timing}
============================================================================

<pre class="idl">
[Exposed=Window]
interface PerformanceContainerTiming : PerformanceEntry {
    readonly attribute DOMString identifier;
    readonly attribute DOMRectReadOnly intersectionRect;
    readonly attribute unsigned long long size;
    readonly attribute DOMHighResTimeStamp firstRenderTime;
    readonly attribute Element? lastPaintedElement;
};

PerformanceContainerTiming includes PaintTimingMixin;
</pre>

<div dfn-for="PerformanceContainerTiming">
Each {{PerformanceContainerTiming}} object has these associated concepts:
* An <dfn for="ContainerTiming">identifier</dfn> initially set to an empty string.
* An <dfn for="ContainerTiming">intersectionRect</dfn> initially set to a {{DOMRectReadOnly}} with all values set to 0.
* A <dfn for="ContainerTiming">size</dfn> initially set to 0.
* A <dfn for="ContainerTiming">firstRenderTime</dfn> initially set to 0.
* A <dfn for="ContainerTiming">lastPaintedElement</dfn> containing the associated {{Element}}, initially set to <code>null</code>.

The {{PerformanceEntry/entryType}} attribute's getter must return the {{DOMString}} <code>"container"</code>.

The {{PerformanceEntry/name}} attribute's getter must return the empty string.

The {{PerformanceEntry/duration}} attribute must return 0.

The {{PerformanceEntry/startTime}} attribute's getter must return the value of [=this=]'s {{ContainerTiming/renderTime}}.

The <dfn attribute>identifier</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/identifier=].

The <dfn attribute>intersectionRect</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/intersectionRect=].

The <dfn attribute>size</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/size=].

The <dfn attribute>firstRenderTime</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/firstRenderTime=].

The <dfn attribute>lastPaintedElement</dfn> attribute must return the value of [=this=]'s [=ContainerTiming/lastPaintedElement=].

</div>

Processing Model {#processing-model}
=====================================

Note: A user agent implementing the Container Timing API would need to include <code>"container"</code> in {{PerformanceObserver/supportedEntryTypes}} for {{Window}} contexts.
This allows developers to detect support for container timing.


Extensions to the {{Element}} Interface {#extensions-to-element}
----------------------------------------------------------------

<em>This section will be removed once the [[DOM]] specification had been modified.<em>

We extend the {{Element}} interface as follows:

<pre class="idl">
partial interface Element {
    [CEReactions] attribute DOMString containertiming;
    [CEReactions] attribute DOMString? containertimingIgnore;
};
</pre>

<div dfn-for="Element">
The <dfn attribute>containertiming</dfn> attribute is a {{DOMString}} that identifies the element as a [=container root=]. The value becomes the {{PerformanceContainerTiming/identifier}} in the corresponding {{PerformanceContainerTiming}} entry.

The <dfn attribute>containertiming-ignore</dfn> attribute, when present, marks the element and its descendants as an [=ignored subtree=] that should not contribute to container timing measurements for ancestor [=container roots=].
</div>

Registering Container Roots {#registering-containers}
------------------------------------------------------

When an {{Element}} with a [^containertiming^] content attribute is connected to the document:

1. The user agent must register the element as a [=container root=].
2. The user agent must initialize an empty [=painted region=] for the [=container root=].
3. The user agent must track all paint operations within the [=container root=]'s subtree, excluding any [=ignored subtrees=].

Report Container Timing Updates {#reporting-updates}
----------------------------------------------------

When asked to <dfn>report a container paint</dfn> given a {{Document}} |document|, a [=PaintTimingMixin/paint timing info=] |paintTimingInfo|, an [=ordered set=] of [=pending image records=] |paintedImages|, and an [=ordered set=] of [=/elements=] |paintedTextNodes|, perform the following steps:

    1. [=list/For each=] |record| of |paintedImages|:
        1. Let |imageElement| be |record|'s [=pending image record/element=].
        1. If |imageElement| is not [=exposed for paint timing=], given |document|, continue.
        1. Let |intersectionRect| be the value returned by the intersection rect algorithm using |imageElement| as the target and viewport as the root.
        1. <a>Potentially add a ContainerTiming entry</a> with |paintTimingInfo|, |imageElement|, |intersectionRect| and |document|.
    1. [=list/For each=] |textNode| of |paintedTextNodes|,
        1. If |textNode| is not [=exposed for paint timing=], given |document|, continue.
        1. Let |textNodeElement| be the <a>set of owned text nodes</a> owning element.
        1. Let |intersectionRect| be an empty rectangle.
        1. [=set/For each=] {{Text}} <a>node</a> |text| of |textNode|'s <a>set of owned text nodes</a>:
            1. Augment |intersectionRect| to be smallest rectangle containing the border box of |text| and |intersectionRect|.
        1. Intersect |intersectionRect| with the visual viewport.
        1. <a>Potentially add a ContainerTiming entry</a> with |paintTimingInfo|, |textNodeElement|, |intersectionRect| and |document|.

<!--
Reporting Paint Updates {#reporting-paint-updates}
---------------------------------------------------

When the rendering engine paints one or more elements within a [=container root=]:

<div algorithm="report container paint">
To report a container paint given a [=container root=] |containerRoot| and a list of painted rectangles |rects|:

1. Let |paintedRegionUpdated| be false.
2. Let |renderTime| be the current high resolution time.
3. Let |firstRenderTime| be |containerRoot|'s stored first render time, or |renderTime| if not yet set.
4. If |containerRoot| does not have a stored first render time, set it to |firstRenderTime|.
5. Let |paintedRegion| be the [=painted region=] associated with |containerRoot|.
6. Let |lastPaintedElement| be null.
7. For each rectangle |rect| in |rects|:
    1. If |rect| is within an [=ignored subtree=], continue to the next |rect|.
    2. If |paintedRegion| already fully contains |rect|, continue to the next |rect|.
    3. Set |paintedRegionUpdated| to true.
    4. Set |paintedRegion| to the union of |paintedRegion| and |rect|.
    5. Set |lastPaintedElement| to the {{Element}} associated with |rect|.
8. If |paintedRegionUpdated| is false, return.
9. [=Queue a PerformanceContainerTiming entry=] with:
    * identifier: the value of |containerRoot|'s {{containertiming}} attribute
    * startTime: |renderTime|
    * firstRenderTime: |firstRenderTime|
    * intersectionRect: the bounding rectangle of |paintedRegion|
    * size: the total area of |paintedRegion|
    * lastPaintedElement: |lastPaintedElement|
            </div>

<div algorithm="queue container timing entry">
To <dfn>queue a PerformanceContainerTiming entry</dfn> given |identifier|, |startTime|, |firstRenderTime|, |intersectionRect|, |size|, and |lastPaintedElement|:

1. Let |entry| be a new {{PerformanceContainerTiming}} object with:
    * {{PerformanceEntry/entryType}}: "<code>container</code>"
    * {{PerformanceEntry/name}}: the empty string
    * {{PerformanceEntry/startTime}}: |startTime|
    * {{PerformanceEntry/duration}}: 0
    * {{PerformanceContainerTiming/identifier}}: |identifier|
    * {{PerformanceContainerTiming/firstRenderTime}}: |firstRenderTime|
    * {{PerformanceContainerTiming/intersectionRect}}: |intersectionRect|
    * {{PerformanceContainerTiming/size}}: |size|
    * {{PerformanceContainerTiming/lastPaintedElement}}: |lastPaintedElement|
2.  <a>Queue the PerformanceEntry</a> |entry|
3. Do not add |entry| to the performance timeline buffer.

Note: Container timing entries are only delivered to {{PerformanceObserver}}s and are not added to the Performance Timeline buffer to avoid memory overhead from potentially frequent updates.
</div>
-->

Contributes to Container Timing {#contributes-to-container-timing}
--------------------------------

An {{Element}} contributes to the container timing of a [=container root=] if all of the following are true:

- It is a descendant of the [=container root=].
- It is not within an [=ignored subtree=].
- It is not in a shadow tree.

<div algorithm="determine contribution to container timing">
To determine whether an {{Element}} |element| contributes to the container timing of a [=container root=] |containerRoot|:

1. If |element| is null, return false.
2. If |element| is in a shadow tree, return false.
3. If |element| is not a descendant of |containerRoot|, return false.
4. If |element| is within an [=ignored subtree=], return false.
5. Return true.
    </div>

Security and Privacy Considerations {#security-privacy}
=======================================================

Cross-Origin Restrictions {#cross-origin}
------------------------------------------

The API respects cross-origin boundaries:

- Elements belonging to cross-origin iframes are not exposed to parent frames.
- No timing information crosses frame boundaries unless explicitly passed by the developer via <code>postMessage</code>.

Information Exposure {#information-exposure}
--------------------------------------------

Most information provided by this API can already be estimated through existing APIs:

- Element Timing returns first rendering time for images and text.
- Paint Timing API provides related timestamps.
- The combination of these APIs could approximate container timing information, though less efficiently.

The API does not expose:

- Internal implementation details of the rendering engine
- Information about elements the developer doesn't already have access to
- Timing information more granular than already available through existing Performance APIs

Timing Attacks {#timing-attacks}
---------------------------------

The API uses {{DOMHighResTimeStamp}} which may be subject to resolution limitations for security purposes, consistent with other Performance APIs.

Privacy Considerations {#privacy}
----------------------------------

The API does not:

- Enable tracking users across sites
- Expose browsing history
- Provide information about user behavior beyond what the site already has access to through script execution

Acknowledgments {#acknowledgments}
===================================

Many thanks for valuable feedback and advice from:

- Barry Pollard
- Michael Mocny
- Scott Haseley
- Sergey Chernyshev

